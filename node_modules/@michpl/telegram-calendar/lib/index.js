"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Calendar = void 0;
class Calendar {
    constructor(_a = {}) {
        var _b, _c;
        var { minDate = null, maxDate = null } = _a, options = __rest(_a, ["minDate", "maxDate"]);
        const defaultWeekDayNames = ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'];
        const defaultOptions = {
            weekDayNames: options.startFromSunday ?
                [defaultWeekDayNames.at(-1), ...defaultWeekDayNames.slice(0, -1)] :
                defaultWeekDayNames,
            monthNames: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            minDate: this.sanitizeMinMaxDate(minDate),
            maxDate: this.sanitizeMinMaxDate(maxDate),
            averageYears: 14,
            callbackDataType: 'calendar',
            ignoreButtonValue: 0,
            yearsInLine: 7,
            startFromSunday: false,
        };
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
        if (!this.isValidMinMaxDate()) {
            throw new Error('Max date lower than min date');
        }
        if (((_b = this.options.weekDayNames) === null || _b === void 0 ? void 0 : _b.length) !== Calendar.WeekLength) {
            throw new Error('Wrong week day names');
        }
        if (((_c = this.options.monthNames) === null || _c === void 0 ? void 0 : _c.length) !== 12) {
            throw new Error('Wrong month names');
        }
    }
    isDate(date) {
        return date instanceof Date && isFinite(date.getTime());
    }
    sanitizeMinMaxDate(inputDate) {
        if (!inputDate)
            return null;
        const date = new Date(inputDate);
        if (!this.isDate(date))
            return null;
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    isValidMinMaxDate() {
        return !this.options.maxDate || !this.options.minDate || this.options.maxDate >= this.options.minDate;
    }
    createCallbackButton(name, value = this.options.ignoreButtonValue, action = null) {
        return {
            text: name,
            callback_data: JSON.stringify({
                type: this.options.callbackDataType,
                date: name.trim() ? value : this.options.ignoreButtonValue,
                action
            })
        };
    }
    addHeader(date) {
        const monthYear = `${this.options.monthNames[date.getMonth()]} ${date.getFullYear()}`;
        const header = [];
        const currentDate = this.formatAnswer(date);
        const result = [];
        this.isInMinMonth(date) ?
            header.push(this.createCallbackButton(' ')) :
            header.push(this.createCallbackButton('<', currentDate, 'prev-month'));
        header.push(this.createCallbackButton(monthYear, currentDate, 'select-year'));
        this.isInMaxMonth(date) ?
            header.push(this.createCallbackButton(' ')) :
            header.push(this.createCallbackButton('>', currentDate, 'next-month'));
        result.push(header);
        result.push(this.options.weekDayNames.map(day => this.createCallbackButton(day)));
        return result;
    }
    isDayAvailable(date, month) {
        if (this.options.minDate && date < this.options.minDate)
            return false;
        if (this.options.maxDate && date > this.options.maxDate)
            return false;
        return date.getMonth() === month;
    }
    addDays(date) {
        const sundayOffset = this.options.startFromSunday ? 1 : -5;
        const notSundayOffset = this.options.startFromSunday ? 1 : 2;
        const firstDay = this.getStartOfMonth(date);
        const lastDay = this.getEndOfMonth(date);
        const month = date.getMonth();
        const isSunday = firstDay.getDay() === 0;
        const startDay = -firstDay.getDay() + (isSunday ? sundayOffset : notSundayOffset);
        const startDate = new Date(firstDay.getFullYear(), firstDay.getMonth(), startDay);
        const result = [];
        let day = startDate;
        while (day <= lastDay) {
            const days = [];
            let newDay;
            for (let i = 0; i < Calendar.WeekLength; i++) {
                newDay = this.addDay(day, i);
                (this.isDayAvailable(newDay, month)) ?
                    days.push(this.createCallbackButton(String(newDay.getDate()), this.formatAnswer(newDay))) :
                    days.push(this.createCallbackButton(' '));
            }
            day = new Date(this.addDay(newDay));
            result.push(days);
        }
        return result;
    }
    leadingZero(data) {
        return (`0${data}`).slice(-2);
    }
    formatAnswer(date) {
        const month = this.leadingZero(date.getMonth() + 1);
        const day = this.leadingZero(date.getDate());
        return `${date.getFullYear()}-${month}-${day}`;
    }
    addDay(date, daysCount = 1) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate() + daysCount);
    }
    getStartOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth(), 1);
    }
    getEndOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth() + 1, 0);
    }
    isValidDate(date) {
        if (this.options.minDate && date < this.options.minDate)
            return false;
        if (this.options.maxDate && date > this.options.maxDate)
            return false;
        return true;
    }
    getPage(inputDate) {
        const date = new Date(inputDate);
        if (!this.isDate(date) || !this.isValidDate(date))
            throw new Error(`Invalid date: ${inputDate}`);
        return [...this.addHeader(date), ...this.addDays(date)];
    }
    getYears(inputDate) {
        const date = new Date(inputDate);
        if (!this.isDate(date) || !this.isValidDate(date))
            throw new Error(`Invalid date: ${inputDate}`);
        const minYear = this.getMinYear(date);
        const maxYear = this.getMaxYear(date);
        let i = minYear;
        const result = [];
        while (i <= maxYear) {
            const string = [];
            for (let j = 0; j < this.options.yearsInLine && i <= maxYear; j++) {
                const newYear = new Date(i, date.getMonth(), date.getDate());
                string.push(this.createCallbackButton(String(i), this.formatAnswer(newYear), 'set-year'));
                i++;
            }
            result.push(string);
        }
        return result;
    }
    getMaxYear(date) {
        const year = date.getFullYear() + this.options.averageYears;
        return (this.options.maxDate) ? Math.min(this.options.maxDate.getFullYear(), year) : year;
    }
    getMinYear(date) {
        const year = date.getFullYear() - this.options.averageYears;
        return (this.options.minDate) ? Math.max(this.options.minDate.getFullYear(), year) : year;
    }
    isInMinMonth(date) {
        return this.isSameMonth(this.options.minDate, date);
    }
    isInMaxMonth(date) {
        return this.isSameMonth(this.options.maxDate, date);
    }
    isSameMonth(optionsDate, date = new Date()) {
        if (!optionsDate)
            return false;
        return optionsDate.getFullYear() === date.getFullYear() && optionsDate.getMonth() === date.getMonth();
    }
}
exports.Calendar = Calendar;
Calendar.WeekLength = 7;
//# sourceMappingURL=index.js.map